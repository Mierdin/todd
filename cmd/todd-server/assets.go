/*
    Asset management for ToDD server

	Copyright 2016 Matt Oswalt. Use or modification of this
	source code is governed by the license provided here:
	https://github.com/toddproject/todd/blob/master/LICENSE
*/

package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/toddproject/todd/assets"
	"github.com/toddproject/todd/config"
	"github.com/toddproject/todd/hostresources"
)

// serveAssets is responsible for deriving embedded assets like collector files and testlets from the golang source generated by go-bindata
// These will be written to the appropriate directories, a hash (SHA256) will be generated, and these files will be served via HTTP
// This function is typically run on the ToDD server.
func serveAssets(cfg config.Config) map[string]map[string]string {
	assetDir := filepath.Join(cfg.LocalResources.OptDir, "assets")

	// Initialize asset map
	assetMap := map[string]map[string]string{
		"factcollectors": hashAssets("facts/collectors"),
		"testlets":       hashAssets("testing/bashtestlets"),
	}

	fmt.Println(assetMap)

	// Hashes and add filesystem factcollectors
	fcHashes, err := hashFiles(filepath.Join(assetDir, "factcollectors"))
	if err != nil {
		panic(err)
	}
	for name, hash := range fcHashes {
		assetMap["factcollectors"][name] = hash
	}

	// Hashes and add filesystem testlets
	testletsHashes, err := hashFiles(filepath.Join(assetDir, "testlets"))
	if err != nil {
		panic(err)
	}
	for name, hash := range testletsHashes {
		assetMap["testlets"][name] = hash
	}

	// Begin serving files to agents
	// TODO(moswalt): Handle error
	go http.ListenAndServe(":"+cfg.Assets.Port, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// check filesystem first
		path := filepath.Join(assetDir, r.URL.Path)
		if _, err := os.Stat(path); err == nil {
			http.ServeFile(w, r, path)
			return
		}

		// If file not on fs, try assets
		path = strings.Replace(r.URL.Path, "/factcollectors", "facts/collectors", 1)
		path = strings.Replace(path, "/testlets", "testing/testlets", 1)

		asset, err := assets.Asset(path)
		if err != nil {
			http.NotFound(w, r)
		}

		w.Write(asset)
	}))

	fmt.Println(assetMap)
	return assetMap
}

// hashAssets returns a mapping of asset filenames to their SHA256 hash.
//
// dir is the path to the files in the assets package.
func hashAssets(dir string) map[string]string {
	names, _ := assets.AssetDir(dir)
	hashes := make(map[string]string, len(names))

	for _, name := range names {
		asset, _ := assets.Asset(dir + "/" + name)
		hasher := sha256.New()
		hasher.Write(asset)

		hashes[name] = hex.EncodeToString(hasher.Sum(nil))
	}

	return hashes
}

// hashFiles returns a mapping of filenames to their SHA256 hash.
//
// dir is the path to the files on the filesystem.
func hashFiles(dir string) (map[string]string, error) {
	finfos, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	hashes := make(map[string]string, len(finfos))
	for _, finfo := range finfos {
		name := finfo.Name()
		hashes[name] = hostresources.GetFileSHA256(filepath.Join(dir, name))
	}

	return hashes, nil
}
